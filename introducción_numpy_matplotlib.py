# -*- coding: utf-8 -*-
"""Introducción_numpy_matplotlib.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hZiq8rZemnT_QUBIYfYkCDVXQwsy2fhf

<center>
<p><img src="https://mcd.unison.mx/wp-content/themes/awaken/img/logo_mcd.png" width="100">
</p>



# Curso Propedéutico en *Programación*

## Introducción a `numpy` y `matplotlib`


**Julio Waissman Vilanova**

</center>

## Iniciando una libreta de `jupyter`

Para inicializar la libreta siempre es saludable (como en la mayoría de los lenguajes de programación) poner al principio las biblotecas (modulos en python), así como los comandos al sistema y de ser posible la descarga de datos.

En este caso vamos a practicar y aprender el uso de los modulos `numpy` y `matplotlib`.

Tambien vamos a utilizar un comando *mágico* para decirle donde queremos los gráficos de `matplotlib`
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt

# Para insertar las gráficas dentro del entorno
# %matplotlib inline

"""Recuerda que hay que ejecutar cada celda (cell) con *ctrl-enter* o con el simbolo de ejecutar. Un número que indica el orden en que se han ido ejecutando las celdas se va apareciendo. Fijate que si la ejecutas varias veces, el número se incrementa.

Un grave problema de diseño de las libretas `jupyter`que siempre molesta (con razón) a los ingenieros de software, es que el orden de las celdas no es mandatorio. Es muy importante conocer la secuencia en que uno ejecutó las celdas, si no, el resultado puede ser inesperado para uno. Veremos unos ejemplos.

La primer linea es un comando conocidos como *comandos mágicos*. En este comando le especificamos a la libreta que vamos a utilizar `matplotlib` para hacer gráficas y que queremos que las anexe dentro del documento.

Si quieres que tu documentación sea atractiva se puede utilizar [estas características de `markdown` que funcionan en las libretas de colab](https://colab.research.google.com/notebooks/markdown_guide.ipynb).

## Pequeños trucos en `jupyter` y colab

En `jupyter` hay varios trucos que facilitan la vida como desarrolladores, vamos a ver unos pocos. Primero y antes que nada, como obtener ayuda sobre una función y autocompletado.

El autocompletado se obtiene con la tecla `TAB`. Una vez que la función, método o clase se encuentra completa, se puede consultar su documentación en linea. Para eso se utilizan la combinación `SHIFT` + `TAB`. Si se realiza una sola vez, Jupyter presenta solo los argumentos, dos veces, se extiende a una pequeña presentación (en cuadro) de los argumentos, tres veces, da una versión más detallada, y 4 veces, lo presenta en un marco independiente, para tener la documentación a la mano mientras se implementa la función.

Sin embargo, en colab las cosas no funcionan igual. Dentro de colab, el autocompletado se realiza en forma automática, y si quiere uno la documentación, se inicia con paréntesis abierto, como si se fuera a aplicar una función o a inicializar un objeto. Entonces empieza la documentación en un *tooltip*. Si es la celda activa, poner el cursor sobre un comando o clase nos da la documentación básica de éste.Otra manera de obtener la documentación, es usando el comando mñagico `?`.

Vamos a experimentar con la primer función que vamos a utilizar en este tutorial:
"""

np.array

"""En Jupyter existen varias funciones que se llaman *mágicas* las cuales empiezan siempre con %. La más común es `%matplotlib inline` para realizar gráficas dentro de la libreta y no que las genere en forma independiente. Otras muy usadas son %time Para calcular el tiempo que tarda en ejecitarse una celda, y %prun para hacer profile de la celda.

Por ejemplo
"""

# Commented out IPython magic to ensure Python compatibility.
# %time sum([x for x in range(100000)])

# Commented out IPython magic to ensure Python compatibility.
# %prun sum([x for x in range(100000)])

"""En general los comandos mágicos se pueden consultar con otro comando mágico"""

# Commented out IPython magic to ensure Python compatibility.
# %quickref

"""Existen muchos comandos mágicos, algunos muy útiles que vamos a ir viendo sobre la marcha. Para una explicacion mas completa vamos a darnos una vueltacita [a esta libreta](https://colab.research.google.com/github/jdwittenauer/ipython-notebooks/blob/master/notebooks/language/IPythonMagic.ipynb).

## Inicializando variables en `numpy`

`numpy` agrega a python básicamente dos nuevos tipos o clases, de los cuales solo nos vamos a interesar por los arreglos multidimensionales o `ndarray`. La manera más sencilla de crear un array (vector o matriz) es utilizando `array` como:
"""

# Crea un objeto vector
vector_a = np.array([1, 3.1416, 40, 0, 2, 5])
print("vector a = " )
print(vector_a)

# Crea una matriz
matriz_A = np.array([[1, 2], [3, 4], [5, 6]])
print("matriz A = ")
print(matriz_A)

type(matriz_A)

"""Esta es la manera más directa pero no la única (y en muchos casos la mas usada) para crear nuevos vectores multidimensionales. Existen otras maneras de generar arreglos como son las funciones:

* `arange(ini=0, fin, inc=1)`: Devuelve un ndarray iniciando en `ini` y terminando en `fin`, con incrementos de inc

* `zeros(dim)`: Devuelve un ndarray de dimensión `dim` (si es un escalar se considera un vector, si es una tupla de números entonces son las dimensiones del ndarray), con todas sus entradas en cero.
      
* `ones(dim)`: Similar a `zeros()` pero con unos.
    
* `eye(x, y=none)`: si solo se tiene el argumento `x` devuelve una matriz identidad de $x \times x$. Si se encuentra `y`, entonces una matriz diagonal rectangular de dimensión x por y.
      
* `zeros_like(x)`: Un ndarray de ceros de la misma dimensión que `x` (igual existe `ones_like`).
    
* `linspace(inicial, final, elementos)`: Devuelve un ndarray de una dimensión iniciando en inicial, hasta final de
manera que existan elementos numeros igualmente espaciados. Muy útil para graficación principalmente.
      
* `random.rand(dim1, dim2, ...)`: Devuelve un ndarray de dimensiones `dim1` por `dim2` por ... con números aleatorios
generados por una distribución uniforme entre 0 y 1.
      
Veamos unos cuantos ejemplos:
"""

vZ = np.zeros(5)
print("Un vector de ceros con 5 valores")
print(vZ)

mO = np.ones((3, 10))
print("Una matriz de 3 x 10 de puron unos")
print(mO)

va = np.arange(10)
print("va = ", va)

vb = np.arange(20,-10,-5)
print(f"vb = {vb}")

print("Una matriz de ceros de las dimensiones de mO:")
print(np.zeros_like(mO))

mA = np.random.rand(5, 12)
print("Y una matriz con números aleatorios bajo una distribución uniforme entre 0 y 1")
print(mA)

"""### Vamos a practicar

En la siguiente celda (o puedes crear las que consideres convenientes) crea las siguientes matrices:

* Una matriz de 4 por 6 con valores aleatorios de acuerdo a una distribución normal con media cero y varianza unitaria.
    
* Un vector de 10 elementos con valores aleatorios de números enteros entre 4 y 100
    
* Una matriz diagonal de 5 por 5 cuyos elementos de la diagonal sean (1, 2, 3, 4, 5)
"""

# Introduce aqui tus respuestas

#Matriz 1

Matriz1 = np.random.randn(4,6)
print(Matriz1)

print()

#Matriz 2

Matriz2 = np.random.randint(4,100,10)
print(Matriz2)


print()

#Matriz 3

Matriz3 = np.diag([1,2,3,4,5])
print(Matriz3)

"""## Operaciones básicas de los ndarray

La mayoría de las operaciones que se pueden aplicar en los `ndarray`
 se encuenran en el espacio de nombres de np, y las cuales son bastante directas tal como:

    b = np.sin(a)

la cual devuelve en b un ndarray de las mismas dimensiones que a, cuyas entradas son el seno de las entradas de a (en radianes).
Así, parece inecesario explicar las funciones cos, tan, tanh, acos, asin, etc..

Otras funciones muy útiles no son tan directas. Veamos algunas:

    c = a + b

es la suma de dos ndarray, bastante obvio, lo que no lo es tanto es:

    c = a * b

la cual es un ndarray resultante de la *multiplicación punto a punto* de los elementos de a y b, asumiendo que ambos tienen
las mismas dimensiones. ¿Y para aplicar un producto matricial? Pues se utiliza el comando dot (o producto punto) el cual puede ser
expresado de tres formas:

    c = np.dot(a, b)
    c = a.dot(b)
    c = a @ b

La suma de los elementos de un ndarray tambien es un método del objeto (como min, max, argmin, argmax, etc...)

    b = a.sum()

es la suma de *todos los elementos del array* mientras que

    b = a.sum(axis=0)

es un ndarray con una dimensión menos que a, con la suma de las columnas. Veamos unos ejemplos:
"""

# Vamos a generar varios ndarrays
a = np.array([[1, 2, 3], [4, 5, 6]])
b = np.random.rand(2, 3)

print("a = ")
print(a)

print("b = ")
print(b)

print("Suma de todos los números de b")
print(b.sum())
print(np.sum(b))

print("Media de cada columna de a")
print(a.mean(axis=0))
print(np.mean(a, axis=0))

print("Transpuesta de a")
print(a.transpose())
print(a.T)

print("10 * b = ")
print(10 * b)

print("a * b =")
print(a * b)

print("2 elevado a la matriz a")
print(np.power(2, a))

print("a elevada al cuadrado (elemento a elemento)")
print(np.power(a, 2))

print("Producto punto de a con b transpuesta")
print(a.dot(b.T))
print(np.dot(a, b.T))
print(a @ b.T)

print("a.dot(b) debería dar error")
print(a.T @ b)

"""Como vemos tenemos aqui una bateria completa de funciones, las cuales se aplican en un ndarray. ¿Pero que información tengo de un ndarray? ¿Como puedo componer un ndarray a partir de otros?  Asumamos por ejemplo un ndarray de una dimensión:"""

#Generamos el ndarray
a = np.arange(100)

# Checamos algunas propiedades
print("El número de dimensiones de a es: ", a.ndim)
print("Y su forma es ", a.shape)
print("Y tiene ", a.size, " elementos")

#Generamos algunos ndarrays a partir de a
b, c = a[:20], a[20:]
d, e = a[-1:-10:-1], a[10:11]
f = a[::-1]
g = a[a % 5 == 0]
h = f[[1, 15, 60]]

# Ahora trata de inferir que es lo que debe contener cada array b, c, d, e, f, g, h sin hacer ninguna prueba.

    #b: contendrá los primeros naturales (0 incluido) hasta el número entero inmediato anterior a 20, i.e. 19.
    #c: contendrá los naturales desde el 20 al número inmediato anterior a 100, i.e. 99.
    #d: Contendrá los elementos desde el -1 al -10 (del 99 al 91) en orden descendiente.
    #e: contendrá todos los elementos desde el 10 al número inmediato anterior a 11, i.e. 10 (solo el 10).
    #f: contendrá todos los elementos de a solo que en orden inverso.
    #g: contendrá todos los elementos de a que son múltiplos de 5.
    #h: contendrá los elementos de f (los de a en orden inverso) que estáne en los índices 1, 15 y 60.

# Agrega ahora los print que consideres necesarios para verificar que valores tiene b, c, d, e, f, g, h

print(b)

print()

print(c)

print()

print(d)

print()

print(e)

print()

print(f)

print()

print(g)

print()

print(h)

h

"""A partir de una matriz (un ndarray de dos dimensiones) se pueden ejemplificar otras cosas, por ejemplo:"""

#Generamos un arreglo con 100 valores equiespaciados del seno desde 0 a 2$\pi$
a = np.sin(np.linspace(0, 2 * np.pi, 100))

#Lo convertimos en una matriz de 10 por *lo que sea* (-1), donde *lo que sea* es 10 en este caso,
b = a.reshape((10, -1))
print("b queda como: ")
print(b)
print("donde b tiene ", b.ndim, " dimensiones, con una forma ", b.shape, "y con ", b.size, " elementos.")

#Si queremos convertir un ndarray a un array de una sola dimension (desenrrollar la matriz podría ser el término)
c = b.ravel()

print("La diferencia absoluta de a y c sería")
print(np.sum(np.abs(a - c)))

# Si queremos hacer que un vector se comporte como un vector renglon
a = np.arange(30).reshape(1,-1)
print("a es de forma ", a.shape)

# Y si queremos que sea un vector columna hacemos esto
b = np.linspace(30, 35, 30).reshape(-1,1)
print("b es de forma ", b.shape)

# Y para hacer una concatenacion de columnas entonces utilizamps la forma especial np._[]
c = np.c_[a.T, b]
print("c es de forma ", c.shape)

#Y una concatenación de renglones es por lo tanto
d = np.r_[a.T, b]
print("d es de forma ", d.shape)

"""### Seguimos practicando

1. Genera una matriz de 100 por 5 de forma que en cada columna tengamos lo siguiente:
    
  - En la primer columna los valores entre -1 y 1, equiespaciados

  - En la segunda columna el valor de seno para los valores de la primer columna

  - En la tercer columna el valor de la función logística de los valores de la primer columna, la cual es   
  $$g(x) = \frac{1}{1 + \exp(-x)}$$

  - En la cuarta columna 1 si el valor de la segunda columna es mayor que cero y -1 en otro caso (revisa la función np.where)

  - En la quinta columna valores aleatorios de acuerdo a una distribución gaussiana con media 1 y varianza 0.5
        
2. Encuentra un arreglo con todos los valores de la función logística, cuando el valor absoluto del seno de x es menor a 0.5 y asignala a una variable llamada `toto_2`
    
3. Convierte este arreglo en una matriz con 5 columnas y los renglones que sean necesarios.
"""

# Escribe aqui tu código


columna1 = np.linspace(-1, 1, 100)
columna2 = np.sin(columna1)
columna3 = 1 / (1 + np.exp(-columna1))
columna4 = np.where(columna2 > 0, 1, -1)
columna5 = np.random.normal(1, np.sqrt(0.5), 100)

matriz = np.column_stack((columna1, columna2, columna3, columna4, columna5))


toto_2 = columna3[np.abs(columna2) < 0.5]

num_rows = int(np.ceil(len(toto_2) / 5))
toto_2_matriz = np.resize(toto_2_values, (num_rows, 5))


print("Matriz original de 100x5:\n", matriz)
print("\nMatriz toto_2:\n", toto_2_matriz)

"""Además de estas funciones, numpy cuenta con funciones del algebra lineal altamente optimizadas (aunque no paralelizadas), las cuales son (entre otras):

* `np.linalg.inv(a)`: Inversa de a
* `np.linalg.pinv(a)`: Pseudoinversa de Ross-Penrose de a (muy útil para nosotros)
* `np.linalg.det(a)`: determinante de a
* `np.linalg.eig(a)`: eigenvalores y eigenvectores de a
* `np.linalg.svd(a)`: Valores singulares de a

## Haciendo gráficas sencillas con Matplotlib

La mejor manera de mostrar como funcionan las facilidades que ofrece matplotlib, es mostrando directamente su uso más sencillo,
así que veamos un ejemplo muy simple. Es importante recordar que en la primer celda de esta libreta se definió la manera de realizar las gráficas (dentro del documento y no como figuras aparte), así como se cargo matplotlib en el espacio de nombres plt.
"""

# Vamos a hacerlo pasito a pasito

# Primero obtenemos un vector x
x = np.linspace(-np.pi, np.pi, 1000)

# Luego obtenemos un vector y bastante trivial
y = np.sin(x)

# Y ahora hacemos una gráfica bastante básica de x y y
plt.plot(x, y)
plt.xlabel("el eje de las x's")
# plt.ylabel("el eje de las y's")
plt.title("Este es un plot bastante trivial y sin mucho chiste")

# Bueno como la gráfica no esta muy bien a lo mejor se ve mejor si modificamos los limites de los ejes
plt.axis([-3.1416, 3.1416, -1.1, 1.1])
plt.show()

"""Aunque a veces queremos hacer unas gráficas más bien indicativas por lo que un estilo más informal podría ser útil:

"""

with plt.xkcd():
    plt.plot(x, y)
    plt.xlabel("el eje de las x's")
    plt.ylabel("el eje de las y's")
    plt.title("Este es un plot bastante trivial y sin mucho chiste")
    plt.axis([-3.1416, 3.1416, -1.1, 1.1])
    plt.show()

"""Hay que tener mucho cuidado, ya que si no se utiliza plt.xkcd() dentro de un with, entonces va a modificar todas las graficas que se realicen en la libreta (a veces es deseable, pero es una mejor práctica de programación hacerlo así)."""

with plt.style.context(('ggplot')):
    plt.plot(x, y)
    plt.xlabel("el eje de las x's")
    plt.ylabel("el eje de las y's")
    plt.title("Este es un plot bastante trivial y sin mucho chiste")
    plt.axis([-3.1416, 3.1416, -1.1, 1.1])
    plt.show()

"""Ahora hagamos una gráfica con varios valores diferentes"""

with plt.style.context(('ggplot')):

  fig = plt.figure(figsize=(10, 5))

  plt.plot(x, np.sin(x), label='seno')
  plt.plot(x, 1/(1 + np.exp(-x)), label=u"logística")
  plt.plot(x, (0.2 * x * x) - 0.5, label=r'$0.2 x^2 - 0.5$')

  plt.axis([-3.1416, 3.1416, -1.1, 1.4])

  plt.title("Tres funciones piteras juntas")
  plt.xlabel(r"$\theta$ (rad)")
  plt.ylabel("magnitud")

  plt.legend(loc=0)

  plt.show()

"""Hay muchos tipos de funciones, lo mejor para saber como utilizar matplotlib es ver la galería de ejemplos que se encuentran en la ayuda,
y pueden consultarse en https://matplotlib.org/stable/gallery/index.html (al darle click a una imagen se puede ver el código que la genera).

Por ejemplo si queremos una gráfica tipo pay:
"""

labels = 'Tortas', 'Taquitos', 'Burros', 'Ensaladas'
porcentajes = [15, 30, 45, 10]
colores = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']
separa = (0, 0.1, 0, 0) # solo separa la segunda rebanada (i.e. 'Taquitos')

with plt.xkcd():
    plt.pie(porcentajes, explode=separa, labels=labels, colors=colores, autopct='%1.1f%%', shadow=True, startangle=90)
    plt.axis('equal') #Para que el pay se vea como un círculo
    plt.xlabel(u'Lo que como cuando no alcanzo a salir a comer')
    plt.show()

"""O si queremos una gráfica tipo contorno con todo y datos"""

from matplotlib import ticker, cm

N = 100
x = np.linspace(-3.0, 3.0, N)
y = np.linspace(-2.0, 2.0, N)

X, Y = np.meshgrid(x, y)

# Vamos a crear un valor de Z usando la suma de dos funciones
Z1 = np.exp(-X**2 - Y**2)
Z2 = np.exp(-(X * 10)**2 - (Y * 10)**2)
z = Z1 + 50 * Z2

# ponemos algunos puntos negativos para ver los problemas que pueden causar:
z[:5, :5] = -1

# Esta linea es para evitar un warning, pero se puede quitar para ver
# que avisa el sistema.
z = np.ma.masked_where(z <= 0, z)


# Automatic selection of levels works; setting the
# log locator tells contourf to use a log scale:
fig, ax = plt.subplots()
cs = ax.contourf(X, Y, z, locator=ticker.LogLocator(), cmap=cm.PuBu_r)

# Tambien se pueden ajustar los niveles de forma manual
# levs = np.linspace(0, z.max(), 200)
# cs = ax.contourf(X, Y, z, levs)

cbar = fig.colorbar(cs)

plt.show()

"""Por último, un detalle muy importante y que puede ser de mucha utilidad: La generación de subplots. Una figura puede contener varias subgraficas, para esto hay que especificar en cuantas gráficas vamos a dividir la figura en forma de renglones y columnas, y luego seleccionar la subgráfica en la que vamos a graficar. Por ejemplo

    plt.subplot(2,2,1)
    
significa que la figura la vamos a dividir en 2 renglones y dos columnas (cuatro subgráficas) y vamos a escribir sobre la subgráfica 1. Lo mejor es ilustrarlo con un ejemplo muy simple.
"""

x = np.linspace(0, 5, 1000)
y1 = np.exp(-0.2 * x) * np.cos(2 * np.pi * x)
y2 = np.cos(2 * np.pi * x)
y3 = np.exp(0.2 * x) * np.cos(2 * np.pi * x)
y4 = np.exp(-0.1 * x)

with plt.style.context(('ggplot')):
  plt.figure(figsize=(15,7))

  plt.subplot(2, 2, 1)
  plt.plot(x, y1)
  plt.title('Estable subamortiguado')

  plt.subplot(2, 2, 2)
  plt.plot(x, y2)
  plt.title('Criticamente estable')

  plt.subplot(2, 2, 3)
  plt.plot(x, y3)
  plt.title('inestable')

  plt.subplot(2, 2, 4)
  plt.plot(x, y4)
  plt.title('Estable sobreamortiguado')

  plt.show()

"""### Practiquemos haciendo algunas gráficas

Realiza lo siguiente en varias celdas abajo de esta:

1. Genera un vector de 1000 datos aleatorios distribuidos de acuerdo a una gaussiana con media 3 y varianza .5, y otro vector con 1000 datos aleatorios distribuidos con una media 0 y una varianza unitaria. Al concatenar los dos vectores, estás generando una serie de datos proveniente de una distribución conocida como suma de gaussianas. Para ver como es esta distribución de datos, realiza un histograma (con un número suficiente de bins).

2. Genera un vector de datos de entrada `x = np.linspace(0, 1, 1000)` y grafica $\sin(2\pi x)$, $\sin(4\pi x)$, $\sin(8\pi x)$. ¿Que conlusión puedes sacar al respecto? Realiza la gráfica con titulo, ejes, etiquetas y todo lo necesario para que sea publicable.

3. Grafíca la función $e^{-t}\cos(2\pi t)$ para $t \in [0, 5]$. Asegurate que la gráfica sea una linea punteada de color rojo, que la gráfica tenga título, etiqueta en el eje de $t$ (tiempo), etiqueta en el eje de $y$ (voltaje en $\mu V$), y una nota donde se escriba la ecuación simulada.

4. Copia un ejemplo de la galería de matplotlib (por ejemplo [este](https://matplotlib.org/stable/gallery/lines_bars_and_markers/spectrum_demo.html#sphx-glr-gallery-lines-bars-and-markers-spectrum-demo-py) o [este](https://matplotlib.org/stable/gallery/images_contours_and_fields/contour_demo.html#sphx-glr-gallery-images-contours-and-fields-contour-demo-py), o [este inclusive](https://matplotlib.org/stable/gallery/lines_bars_and_markers/fill_between_demo.html#sphx-glr-gallery-lines-bars-and-markers-fill-between-demo-py)) y modificalo para que se grafique dentro de la libreta. Una vez funcionando, comenta el código, dejando bien claro **en español y con tus palabras** que es lo que hace cada una de las lineas.
"""

#Problema 1

vector1 = np.random.normal(3, np.sqrt(0.5), 1000)
vector2 = np.random.normal(0, 1, 1000)


combinacion = np.concatenate((vector1, vector2))

plt.hist(combinacion, bins=50)

plt.title('Histograma de la Suma de Gaussianas')
plt.xlabel('Valor')
plt.ylabel('Densidad')


plt.show()

#Problema 2

x = np.linspace(0, 1, 1000)

y1 = np.sin(2 * np.pi * x)
y2 = np.sin(4 * np.pi * x)
y3 = np.sin(8 * np.pi * x)

plt.figure(figsize=(10, 6))

plt.plot(x, y1, label='sin(2πx)')
plt.plot(x, y2, label='sin(4πx)')
plt.plot(x, y3, label='sin(8πx)')

plt.title('Gráfica de sin(2πx), sin(4πx) y sin(8πx)')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()

plt.show()

#Problema 3

t = np.linspace(0, 5, 1000)

y = np.exp(-t) * np.cos(2 * np.pi * t)


plt.figure(figsize=(10, 6))


plt.plot(t, y, 'r--', label='$e^{-t} \cos(2 \pi t)$')


plt.title('Gráfica de $e^{-t} \cos(2 \pi t)$')
plt.xlabel('Tiempo (t)')
plt.ylabel('Voltaje ($\mu$V)')


plt.text(2.5, 0.5, r'$e^{-t} \cos(2 \pi t)$')



plt.legend()
plt.show()

#Problema 4

np.random.seed(0)                                                                ### Semilla de números aleatorios para reproducibilidad

dt = 0.01  # sampling interval                                                   ### Define el intervalo de muestreo, es decir, la separación entre los puntos de tiempo.
Fs = 1 / dt  # sampling frequency                                                ### Es la frecuencia de muestreo, calculada como el inverso del intervalo de muestreo.
t = np.arange(0, 10, dt)                                                         ### Es un vector que contiene los puntos de tiempo desde 0 hasta 10 segundos, con incrementos de dt.

# generate noise:
nse = np.random.randn(len(t))                                                    ### Genera un vector de números aleatorios con distribución normal.
r = np.exp(-t / 0.05)                                                            ### Se define r como el vector al que se le aplica la función exponencial exp(-t/0.05)
cnse = np.convolve(nse, r) * dt                                                  ### Es el ruido convolucionado escalado por dt.
cnse = cnse[:len(t)]                                                             ### Ajusta la longitud del array cnse para que coincida con la longitud del array t

s = 0.1 * np.sin(4 * np.pi * t) + cnse  # the signal                             ### Suma el resultado de aplicar la función descrita con el cnse

fig = plt.figure(figsize=(7, 7), layout='constrained')                           ### Se crea una figura con un tamaño particular
axs = fig.subplot_mosaic([["signal", "signal"],                                  ### Se organizan las subgraficas
                          ["magnitude", "log_magnitude"],
                          ["phase", "angle"]])

# plot time signal:
axs["signal"].set_title("Signal")                                                ### Se define una gráfica para "signal"
axs["signal"].plot(t, s, color='C0')                                             ### Se le da un color a la gráfica
axs["signal"].set_xlabel("Time (s)")                                             ### Se nombra el eje x
axs["signal"].set_ylabel("Amplitude")                                            ### Se nombra el eje y

# plot different spectrum types:
axs["magnitude"].set_title("Magnitude Spectrum")                                 ### Se define la gráfica "Magnitude Spectrum"
axs["magnitude"].magnitude_spectrum(s, Fs=Fs, color='C1')                        ### Se establecen especificaciones para la graficación (variable, frecuencia, escala, color)

axs["log_magnitude"].set_title("Log. Magnitude Spectrum")                        ### Se define la gráfica "Log. Magnitude Spectrum"
axs["log_magnitude"].magnitude_spectrum(s, Fs=Fs, scale='dB', color='C1')        ### Se establecen especificaciones para la graficación (variable, frecuencia, escala, color)

axs["phase"].set_title("Phase Spectrum ")                                        ### Se define la gráfica "Phase Spectrum"
axs["phase"].phase_spectrum(s, Fs=Fs, color='C2')                                ### Se establecen especificaciones para la graficación (variable, frecuencia, escala, color)

axs["angle"].set_title("Angle Spectrum")                                         ### Se define la gráfica "Angle Spectrum"
axs["angle"].angle_spectrum(s, Fs=Fs, color='C2')                                ### Se establecen especificaciones para la graficación (variable, frecuencia, escala, color)

plt.show()                                                                       ### Muestra las gráficas